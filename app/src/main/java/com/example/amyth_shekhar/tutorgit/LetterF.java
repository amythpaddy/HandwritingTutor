package com.example.amyth_shekhar.tutorgit;
        import android.graphics.Paint;
        import android.graphics.RectF;
        import android.graphics.Canvas;
        import android.graphics.Color;
        import android.graphics.Path;



/**
 * Created by null on Feb 8, 2018.
 * Copyright Â© 2018 null. All rights reserved.
 *
 * This code was generated by Trial version of PaintCode, therefore cannot be used for commercial purposes.
 * http://www.paintcodeapp.com
 *
 * @author null
 */
public class LetterF{


    // Resizing Behavior
    public enum ResizingBehavior {
        AspectFit, //!< The content is proportionally resized to fit into the target rectangle.
        AspectFill, //!< The content is proportionally resized to completely fill the target rectangle.
        Stretch, //!< The content is stretched to match the entire target rectangle.
        Center, //!< The content is centered in the target rectangle, but it is NOT resized.
    }

    // In Trial version of PaintCode, the code generation is limited to 3 canvases.

    // Canvas Drawings
    // Tab

    private static class CacheForF {
        private static Paint paint = new Paint();
        private static RectF originalFrame = new RectF(0f, 0f, 294f, 284f);
        private static RectF resizedFrame = new RectF();
        private static RectF text2Rect = new RectF();
        private static Path text2Path = new Path();
    }

    public static void drawF(Canvas canvas) {
        LetterF.drawF(canvas, new RectF(0f, 0f, 294f, 284f), ResizingBehavior.AspectFit);
    }

    public static void drawF(Canvas canvas, ResizingBehavior behavior) {
        LetterF.drawF(canvas, new RectF(0f, 0f, 400f, 400f), behavior);
    }

    public static void drawF(Canvas canvas, RectF targetFrame, ResizingBehavior resizing) {
        // General Declarations
        Paint paint = CacheForF.paint;

        // Resize to Target Frame
        canvas.save();
        RectF resizedFrame = CacheForF.resizedFrame;
        LetterF.resizingBehaviorApply(resizing, CacheForF.originalFrame, targetFrame, resizedFrame);
        canvas.translate(resizedFrame.left, resizedFrame.top);
        canvas.scale(resizedFrame.width() / 294f, resizedFrame.height() / 284f);

        // Text 2
        RectF text2Rect = CacheForF.text2Rect;
        text2Rect.set(92.63f, 19f, 214.63f, 275.5f);
        Path text2Path = CacheForF.text2Path;
        text2Path.reset();
        text2Path.moveTo(107.38f, 19f);
        text2Path.lineTo(199.88f, 19f);
        text2Path.cubicTo(209.71f, 19f, 214.63f, 23.92f, 214.63f, 33.75f);
        text2Path.cubicTo(214.63f, 41.58f, 209.71f, 46.17f, 199.88f, 47.5f);
        text2Path.lineTo(121.38f, 47.5f);
        text2Path.lineTo(121.38f, 136.5f);
        text2Path.lineTo(195.38f, 136.5f);
        text2Path.cubicTo(208.21f, 136.5f, 214.63f, 141f, 214.63f, 150f);
        text2Path.lineTo(214.63f, 151.25f);
        text2Path.cubicTo(214.63f, 161.08f, 207.04f, 166f, 191.88f, 166f);
        text2Path.lineTo(121.38f, 166f);
        text2Path.lineTo(121.38f, 259.75f);
        text2Path.cubicTo(121.38f, 270.25f, 115.96f, 275.5f, 105.13f, 275.5f);
        text2Path.cubicTo(98.12f, 275.5f, 93.96f, 270.5f, 92.63f, 260.5f);
        text2Path.lineTo(92.63f, 33.75f);
        text2Path.cubicTo(93.29f, 23.92f, 98.21f, 19f, 107.38f, 19f);
        text2Path.close();

        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setStrokeWidth(5f);
        paint.setStrokeMiter(10f);
        canvas.save();
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(Color.BLACK);
        canvas.drawPath(text2Path, paint);
        canvas.restore();

        canvas.restore();
    }


    // Resizing Behavior
    public static void resizingBehaviorApply(ResizingBehavior behavior, RectF rect, RectF target, RectF result) {
        if (rect.equals(target) || target == null) {
            result.set(rect);
            return;
        }

        if (behavior == ResizingBehavior.Stretch) {
            result.set(target);
            return;
        }

        float xRatio = Math.abs(target.width() / rect.width());
        float yRatio = Math.abs(target.height() / rect.height());
        float scale = 0f;

        switch (behavior) {
            case AspectFit: {
                scale = Math.min(xRatio, yRatio);
                break;
            }
            case AspectFill: {
                scale = Math.max(xRatio, yRatio);
                break;
            }
            case Center: {
                scale = 1f;
                break;
            }

            case Stretch:{

                break;
            }
        }

        float newWidth = Math.abs(rect.width() * scale);
        float newHeight = Math.abs(rect.height() * scale);
        result.set(target.centerX() - newWidth / 2,
                target.centerY() - newHeight / 2,
                target.centerX() + newWidth / 2,
                target.centerY() + newHeight / 2);
    }


}
